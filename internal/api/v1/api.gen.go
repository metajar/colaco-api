// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Soda Represents a soda available for purchase, including metadata such as name, description, origin story, calories, and volume in ounces. This schema is used to detail the sodas offered by the vending machine, allowing users to make informed choices.
type Soda struct {
	Calories    *int     `json:"calories,omitempty"`
	Description *string  `json:"description,omitempty"`
	Name        *string  `json:"name,omitempty"`
	OriginStory *string  `json:"originStory,omitempty"`
	Ounces      *float32 `json:"ounces,omitempty"`
}

// VendingSlot Defines a slot within the vending machine, containing a soda, its cost, maximum quantity, and current stock level. This schema is crucial for managing the inventory and pricing of sodas, ensuring a seamless vending operation.
type VendingSlot struct {
	Cost        *float32 `json:"cost,omitempty"`
	MaxQuantity *int     `json:"maxQuantity,omitempty"`

	// OccupiedSoda Represents a soda available for purchase, including metadata such as name, description, origin story, calories, and volume in ounces. This schema is used to detail the sodas offered by the vending machine, allowing users to make informed choices.
	OccupiedSoda *Soda `json:"occupiedSoda,omitempty"`
	Quantity     *int  `json:"quantity,omitempty"`
}

// AuthTokenResponse defines model for AuthTokenResponse.
type AuthTokenResponse struct {
	Token *string `json:"token,omitempty"`
}

// ErrorResp defines model for ErrorResp.
type ErrorResp struct {
	Error *string `json:"error,omitempty"`
}

// MessageResponse defines model for MessageResponse.
type MessageResponse struct {
	Message *string `json:"message,omitempty"`
}

// PurchaseSodaResponse defines model for PurchaseSodaResponse.
type PurchaseSodaResponse struct {
	Change *float32 `json:"change,omitempty"`

	// Soda Represents a soda available for purchase, including metadata such as name, description, origin story, calories, and volume in ounces. This schema is used to detail the sodas offered by the vending machine, allowing users to make informed choices.
	Soda *Soda `json:"soda,omitempty"`
}

// RestockResponse defines model for RestockResponse.
type RestockResponse struct {
	Leftover    *int `json:"leftover,omitempty"`
	NewQuantity *int `json:"newQuantity,omitempty"`
	OldQuantity *int `json:"oldQuantity,omitempty"`
}

// UpdatePriceResp defines model for UpdatePriceResp.
type UpdatePriceResp struct {
	NewPrice *float32 `json:"newPrice,omitempty"`
	OldPrice *float32 `json:"oldPrice,omitempty"`
	SlotName *string  `json:"slotName,omitempty"`
}

// VendingMachineResponse defines model for VendingMachineResponse.
type VendingMachineResponse struct {
	Slots *[]VendingSlot `json:"slots,omitempty"`
	Total *int           `json:"total,omitempty"`
}

// AuthRequestBody defines model for AuthRequestBody.
type AuthRequestBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// NewVendingSlotRequestBody defines model for NewVendingSlotRequestBody.
type NewVendingSlotRequestBody struct {
	// Slot Defines a slot within the vending machine, containing a soda, its cost, maximum quantity, and current stock level. This schema is crucial for managing the inventory and pricing of sodas, ensuring a seamless vending operation.
	Slot VendingSlot `json:"slot"`
}

// PurchaseSodaBody defines model for PurchaseSodaBody.
type PurchaseSodaBody struct {
	Name    string  `json:"name"`
	Payment float32 `json:"payment"`
}

// RestockRequestBody defines model for RestockRequestBody.
type RestockRequestBody struct {
	Name     string `json:"name"`
	Quantity int    `json:"quantity"`
}

// UpdatePriceBody defines model for UpdatePriceBody.
type UpdatePriceBody struct {
	Name     string  `json:"name"`
	NewPrice float32 `json:"newPrice"`
}

// VendingSlotRequestBody defines model for VendingSlotRequestBody.
type VendingSlotRequestBody struct {
	Name string `json:"name"`
}

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// PostPurchaseJSONBody defines parameters for PostPurchase.
type PostPurchaseJSONBody struct {
	Name    string  `json:"name"`
	Payment float32 `json:"payment"`
}

// RestockSodaJSONBody defines parameters for RestockSoda.
type RestockSodaJSONBody struct {
	Name     string `json:"name"`
	Quantity int    `json:"quantity"`
}

// UpdatePriceJSONBody defines parameters for UpdatePrice.
type UpdatePriceJSONBody struct {
	Name     string  `json:"name"`
	NewPrice float32 `json:"newPrice"`
}

// DeleteVendingJSONBody defines parameters for DeleteVending.
type DeleteVendingJSONBody struct {
	Name string `json:"name"`
}

// GetVendingJSONBody defines parameters for GetVending.
type GetVendingJSONBody struct {
	Name string `json:"name"`
}

// PostNewJSONBody defines parameters for PostNew.
type PostNewJSONBody struct {
	// Slot Defines a slot within the vending machine, containing a soda, its cost, maximum quantity, and current stock level. This schema is crucial for managing the inventory and pricing of sodas, ensuring a seamless vending operation.
	Slot VendingSlot `json:"slot"`
}

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// PostPurchaseJSONRequestBody defines body for PostPurchase for application/json ContentType.
type PostPurchaseJSONRequestBody PostPurchaseJSONBody

// RestockSodaJSONRequestBody defines body for RestockSoda for application/json ContentType.
type RestockSodaJSONRequestBody RestockSodaJSONBody

// UpdatePriceJSONRequestBody defines body for UpdatePrice for application/json ContentType.
type UpdatePriceJSONRequestBody UpdatePriceJSONBody

// DeleteVendingJSONRequestBody defines body for DeleteVending for application/json ContentType.
type DeleteVendingJSONRequestBody DeleteVendingJSONBody

// GetVendingJSONRequestBody defines body for GetVending for application/json ContentType.
type GetVendingJSONRequestBody GetVendingJSONBody

// PostNewJSONRequestBody defines body for PostNew for application/json ContentType.
type PostNewJSONRequestBody PostNewJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AuthLoginWithBody request with any body
	AuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLogin(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPurchaseWithBody request with any body
	PostPurchaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPurchase(ctx context.Context, body PostPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestockSodaWithBody request with any body
	RestockSodaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestockSoda(ctx context.Context, body RestockSodaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePriceWithBody request with any body
	UpdatePriceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePrice(ctx context.Context, body UpdatePriceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVendingWithBody request with any body
	DeleteVendingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVending(ctx context.Context, body DeleteVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVendingWithBody request with any body
	GetVendingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetVending(ctx context.Context, body GetVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNewWithBody request with any body
	PostNewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNew(ctx context.Context, body PostNewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogin(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchase(ctx context.Context, body PostPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestockSodaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestockSodaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestockSoda(ctx context.Context, body RestockSodaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestockSodaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePriceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePriceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrice(ctx context.Context, body UpdatePriceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePriceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVendingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVendingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVending(ctx context.Context, body DeleteVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVendingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVendingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVendingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVending(ctx context.Context, body GetVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVendingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNew(ctx context.Context, body PostNewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAuthLoginRequest calls the generic AuthLogin builder with application/json body
func NewAuthLoginRequest(server string, body AuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthLoginRequestWithBody generates requests for AuthLogin with any type of body
func NewAuthLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPurchaseRequest calls the generic PostPurchase builder with application/json body
func NewPostPurchaseRequest(server string, body PostPurchaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPurchaseRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPurchaseRequestWithBody generates requests for PostPurchase with any type of body
func NewPostPurchaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchase")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestockSodaRequest calls the generic RestockSoda builder with application/json body
func NewRestockSodaRequest(server string, body RestockSodaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestockSodaRequestWithBody(server, "application/json", bodyReader)
}

// NewRestockSodaRequestWithBody generates requests for RestockSoda with any type of body
func NewRestockSodaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePriceRequest calls the generic UpdatePrice builder with application/json body
func NewUpdatePriceRequest(server string, body UpdatePriceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePriceRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdatePriceRequestWithBody generates requests for UpdatePrice with any type of body
func NewUpdatePriceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updatePrice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVendingRequest calls the generic DeleteVending builder with application/json body
func NewDeleteVendingRequest(server string, body DeleteVendingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVendingRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteVendingRequestWithBody generates requests for DeleteVending with any type of body
func NewDeleteVendingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vending")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVendingRequest calls the generic GetVending builder with application/json body
func NewGetVendingRequest(server string, body GetVendingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetVendingRequestWithBody(server, "application/json", bodyReader)
}

// NewGetVendingRequestWithBody generates requests for GetVending with any type of body
func NewGetVendingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vending")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNewRequest calls the generic PostNew builder with application/json body
func NewPostNewRequest(server string, body PostNewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNewRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNewRequestWithBody generates requests for PostNew with any type of body
func NewPostNewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vending")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AuthLoginWithBodyWithResponse request with any body
	AuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	AuthLoginWithResponse(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	// PostPurchaseWithBodyWithResponse request with any body
	PostPurchaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseResponse, error)

	PostPurchaseWithResponse(ctx context.Context, body PostPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseResponse, error)

	// RestockSodaWithBodyWithResponse request with any body
	RestockSodaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestockSodaResponse, error)

	RestockSodaWithResponse(ctx context.Context, body RestockSodaJSONRequestBody, reqEditors ...RequestEditorFn) (*RestockSodaResponse, error)

	// UpdatePriceWithBodyWithResponse request with any body
	UpdatePriceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePriceResponse, error)

	UpdatePriceWithResponse(ctx context.Context, body UpdatePriceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePriceResponse, error)

	// DeleteVendingWithBodyWithResponse request with any body
	DeleteVendingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVendingResponse, error)

	DeleteVendingWithResponse(ctx context.Context, body DeleteVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVendingResponse, error)

	// GetVendingWithBodyWithResponse request with any body
	GetVendingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVendingResponse, error)

	GetVendingWithResponse(ctx context.Context, body GetVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVendingResponse, error)

	// PostNewWithBodyWithResponse request with any body
	PostNewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNewResponse, error)

	PostNewWithResponse(ctx context.Context, body PostNewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNewResponse, error)
}

type AuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokenResponse
	JSON401      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r AuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PurchaseSodaResponse
	JSON402      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r PostPurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestockSodaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestockResponse
	JSON404      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r RestockSodaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestockSodaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePriceResp
	JSON404      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVendingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
	JSON404      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVendingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVendingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVendingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VendingMachineResponse
	JSON404      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r GetVendingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVendingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessageResponse
	JSON409      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r PostNewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AuthLoginWithBodyWithResponse request with arbitrary body returning *AuthLoginResponse
func (c *ClientWithResponses) AuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) AuthLoginWithResponse(ctx context.Context, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

// PostPurchaseWithBodyWithResponse request with arbitrary body returning *PostPurchaseResponse
func (c *ClientWithResponses) PostPurchaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseResponse, error) {
	rsp, err := c.PostPurchaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseResponse(rsp)
}

func (c *ClientWithResponses) PostPurchaseWithResponse(ctx context.Context, body PostPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseResponse, error) {
	rsp, err := c.PostPurchase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseResponse(rsp)
}

// RestockSodaWithBodyWithResponse request with arbitrary body returning *RestockSodaResponse
func (c *ClientWithResponses) RestockSodaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestockSodaResponse, error) {
	rsp, err := c.RestockSodaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestockSodaResponse(rsp)
}

func (c *ClientWithResponses) RestockSodaWithResponse(ctx context.Context, body RestockSodaJSONRequestBody, reqEditors ...RequestEditorFn) (*RestockSodaResponse, error) {
	rsp, err := c.RestockSoda(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestockSodaResponse(rsp)
}

// UpdatePriceWithBodyWithResponse request with arbitrary body returning *UpdatePriceResponse
func (c *ClientWithResponses) UpdatePriceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePriceResponse, error) {
	rsp, err := c.UpdatePriceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePriceResponse(rsp)
}

func (c *ClientWithResponses) UpdatePriceWithResponse(ctx context.Context, body UpdatePriceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePriceResponse, error) {
	rsp, err := c.UpdatePrice(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePriceResponse(rsp)
}

// DeleteVendingWithBodyWithResponse request with arbitrary body returning *DeleteVendingResponse
func (c *ClientWithResponses) DeleteVendingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVendingResponse, error) {
	rsp, err := c.DeleteVendingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVendingResponse(rsp)
}

func (c *ClientWithResponses) DeleteVendingWithResponse(ctx context.Context, body DeleteVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVendingResponse, error) {
	rsp, err := c.DeleteVending(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVendingResponse(rsp)
}

// GetVendingWithBodyWithResponse request with arbitrary body returning *GetVendingResponse
func (c *ClientWithResponses) GetVendingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVendingResponse, error) {
	rsp, err := c.GetVendingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVendingResponse(rsp)
}

func (c *ClientWithResponses) GetVendingWithResponse(ctx context.Context, body GetVendingJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVendingResponse, error) {
	rsp, err := c.GetVending(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVendingResponse(rsp)
}

// PostNewWithBodyWithResponse request with arbitrary body returning *PostNewResponse
func (c *ClientWithResponses) PostNewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNewResponse, error) {
	rsp, err := c.PostNewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNewResponse(rsp)
}

func (c *ClientWithResponses) PostNewWithResponse(ctx context.Context, body PostNewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNewResponse, error) {
	rsp, err := c.PostNew(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNewResponse(rsp)
}

// ParseAuthLoginResponse parses an HTTP response from a AuthLoginWithResponse call
func ParseAuthLoginResponse(rsp *http.Response) (*AuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostPurchaseResponse parses an HTTP response from a PostPurchaseWithResponse call
func ParsePostPurchaseResponse(rsp *http.Response) (*PostPurchaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PurchaseSodaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	}

	return response, nil
}

// ParseRestockSodaResponse parses an HTTP response from a RestockSodaWithResponse call
func ParseRestockSodaResponse(rsp *http.Response) (*RestockSodaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestockSodaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestockResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePriceResponse parses an HTTP response from a UpdatePriceWithResponse call
func ParseUpdatePriceResponse(rsp *http.Response) (*UpdatePriceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePriceResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVendingResponse parses an HTTP response from a DeleteVendingWithResponse call
func ParseDeleteVendingResponse(rsp *http.Response) (*DeleteVendingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVendingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVendingResponse parses an HTTP response from a GetVendingWithResponse call
func ParseGetVendingResponse(rsp *http.Response) (*GetVendingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVendingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VendingMachineResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostNewResponse parses an HTTP response from a PostNewWithResponse call
func ParsePostNewResponse(rsp *http.Response) (*PostNewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate user and issue JWT
	// (POST /auth/login)
	AuthLogin(ctx echo.Context) error
	// Purchase Soda from vending machine
	// (POST /purchase)
	PostPurchase(ctx echo.Context) error
	// Restock a soda
	// (POST /restock)
	RestockSoda(ctx echo.Context) error
	// Update the price of a soda
	// (PUT /updatePrice)
	UpdatePrice(ctx echo.Context) error
	// Delete Slot And Return Sodas
	// (DELETE /vending)
	DeleteVending(ctx echo.Context) error
	// Get vending machine slots
	// (GET /vending)
	GetVending(ctx echo.Context) error
	// Add New Soda and Vending Slot
	// (POST /vending)
	PostNew(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogin(ctx)
	return err
}

// PostPurchase converts echo context to params.
func (w *ServerInterfaceWrapper) PostPurchase(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPurchase(ctx)
	return err
}

// RestockSoda converts echo context to params.
func (w *ServerInterfaceWrapper) RestockSoda(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RestockSoda(ctx)
	return err
}

// UpdatePrice converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePrice(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePrice(ctx)
	return err
}

// DeleteVending converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteVending(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteVending(ctx)
	return err
}

// GetVending converts echo context to params.
func (w *ServerInterfaceWrapper) GetVending(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVending(ctx)
	return err
}

// PostNew converts echo context to params.
func (w *ServerInterfaceWrapper) PostNew(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostNew(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/auth/login", wrapper.AuthLogin)
	router.POST(baseURL+"/purchase", wrapper.PostPurchase)
	router.POST(baseURL+"/restock", wrapper.RestockSoda)
	router.PUT(baseURL+"/updatePrice", wrapper.UpdatePrice)
	router.DELETE(baseURL+"/vending", wrapper.DeleteVending)
	router.GET(baseURL+"/vending", wrapper.GetVending)
	router.POST(baseURL+"/vending", wrapper.PostNew)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"BdeN9eH2+vT6tPj81+f/DQAA///x4UQCGjgAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
